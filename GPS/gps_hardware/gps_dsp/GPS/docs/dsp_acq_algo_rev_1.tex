\documentclass[journal,10pt,onecolumn]{article}
\usepackage{graphicx}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsmath}
\usepackage{array}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{titlesec}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts} 
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\usepackage{enumerate}
\let\vec\mathbf
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\titleformat{\section}[block]{\centering\large\bfseries}{}{0pt}{}

\lstset{
frame=single,
breaklines=true,
columns=fullflexible
}

\begin{document}
\section*{GPS Signal Description}

\begin{enumerate}

    \item The baseband signal \textbf{transmited} by the satellite is given as 
    \begin{equation}
        S(t) = S_{PPS}(t)+ jS_{SPS}(t)
    \end{equation} 
    \begin{enumerate}
        \item[$\bullet$]  $S_{SPS}(t) = 	\sum_{i=-\infty}^{\infty}  c_{sps}(|i|_{L\_sps}) . d([i]_{CD\_sps}) . rect_{T_{c,sps}}(t-iT_{c,sps})$ --- Standard Positioning Service
        \item[$\bullet$] $S_{PPS}(t) = 	\sum_{i=-\infty}^{\infty}  c_{pps}(|i|_{L\_pps}) . d([i]_{CD\_pps}) . rect_{T_{c,pps}}(t-iT_{c,pps}) $ ----   Precision Positioning Service
    \end{enumerate}
    \item Let $x_{in}[n]$ be the incoming signal at the \textbf{receiver} end and is given as
	\begin{equation}
        x_{in}[n] = A(t) s_T(t-\tau (t))e^{j(2\pi f_D (t)t+\phi (t))}|_{t=nT_s}  + n(t)\vert _{t=nT_s}
    \end{equation}
    where \\
    \begin{enumerate}
        \item[$\bullet$] $A(t)$ is Amplitude
        \item[$\bullet$] $s_T(t)$ is Complex baseband signal
        \item[$\bullet$] $\tau(t)$ is code delay(time varying)
        \item[$\bullet$] $f_D(t)$ is Doppler shift(time varying)
        \item[$\bullet$] $\phi(t)$ is carrier phase shift(time varying)
        \item[$\bullet$]  $n(t)$ is Random noise with zero mean
        \item[$\bullet$] $T_s$ is Sampling period
        \item[$\bullet$] $f_s$ is Sampling frequency
    \end{enumerate}
\end{enumerate}


\section{Pseudo code for GPS Signal Acquisition}

\subsection{Functions for computing the PRN codes of GPS satellite}
\begin{enumerate}
    \item 
    \begin{enumerate}
    \item g1$\_$lfsr()
    \begin{enumerate}
    \item[] \textbf{int16} state = 0x3FF
    \item[] \textbf{int8} out[1023]
    \item[] \textbf{int8} new$\_$bit
    \item[] \textbf{for} \textbf{i}=0 to \textbf{i}=1022
        \begin{enumerate}
            \item[] out[\textbf{i}] = (state $\gg$ 9) \& 0x1 
            \item[] new$\_$bit = ((state $\gg$ 9) $\oplus$ (state $\gg$ 2)) $\&$ 0x1
            \item[] state = ((state $\ll$ 1) $\vert$  new$\_$bit) $\&$ 0x3FF
        \end{enumerate}
    \item[] \textbf{end for}
    \item[] return out
    \end{enumerate}
    
    

    \item g2$\_$lfsr(\textbf{int8} tap0,\textbf{int8} tap1)
    \begin{enumerate}
        \item[] \textbf{int16} state = 0x3FF
        \item[] \textbf{int8}  out[1023]
        \item[] tap0 = tap0-1
        \item[] tap1 = tap1-1 
        \item[] \textbf{for} \textbf{i}=0 to \textbf{i}=1022
        \begin{enumerate}
            \item[] out[\textbf{i}] = ((state $\gg$ tap0) $\oplus$ (state $\gg$ tap1)) $\&$ 0x1
            \item[] new$\_$bit =  ((state $\gg$ 9) $\oplus$ (state $\gg$ 8) $\oplus$
            (state $\gg$ 7) $\oplus$ (state $\gg$ 5) $\oplus$
            (state $\gg$ 2) $\oplus$ (state $\gg$ 1)) $\&$ 0x1
            \item[] state = ((state $\ll$ 1) $\vert$ new$\_$bit) $\&$ 0x3FF
        \end{enumerate}
        \item[] \textbf{end for}
        \item[] return out
    \end{enumerate}
    




    \item combine$\_$g1$\_$g2(\textbf{int16} *g1,\textbf{int16} *g2)
    \begin{enumerate}
        \item[] \textbf{int8} out[1023]
        \item[] \textbf{for} \textbf{i}=0 to \textbf{i}=1022
        \begin{enumerate}
            \item[] out[\textbf{i}] = g1[\textbf{i}] $\oplus$ g2[\textbf{i}]
        \end{enumerate}
        \item[]  \textbf{end for}
        \item[]  return out
    \end{enumerate}
    


\end{enumerate}
\end{enumerate}

\subsection{Main function}
\begin{enumerate} 
\item[]   

\item[] \textbf{int32} $f_c$ = 1023000 \hspace{5mm} /* PRN code frequency */
\item[] \textbf{int32} $f_s$ = 2048000 \hspace{5mm} /* Sampling frequency */ 
\item[] \textbf{int16} N = 2048        \hspace{5mm} /* Samples for 1ms is 2048 */ 
\item[] \textbf{cint16} \textbf{incoming$\_$signal} [4096] \hspace{5mm} /* Incoming 2ms  Samples  */  
\item[] \textbf{cint16} \textbf{*incoming$\_$signalpower}
\item []
\item[] /*Calculate the power of signal*/
\item[] \textbf{CEVA$\_$DSP$\_$LIB$\_$MAT$\_$CX$\_$MUL$\_$TRANS$\textunderscore$Q15}(\textbf{x},\textbf{1,2048,incoming$\_$signalpower})  
\item[] The power of incoming signal should be \textbf{ incoming$\_$signalpower$>$ threshold} . If true, \textbf{go to} step \textbf{8}. else, \textbf{stop} the process
\item[] 

   
    
    \item[] \textbf{int16} max$\_$power[5] = $\{0\}$ 
    \item[] \textbf{int8} visible$\_$satellites$\_$withMaxPower[5] = $\{0\}$
    \item[] \textbf{int16} codePhase[5] = $\{0\}$
    \item[] \textbf{int16} visible$\_$PRN$\_$codes[5][2048] = $\{\{0\}\}$  \hspace{5mm} /* Matrix to store the PRN codes of visible satellites */ 
    \item[] \textbf{int32} log2$\_$FFT$\_$size = 11;  \hspace{5mm} /* FFT size = $2^{11}$ */  
    \item[] \textbf{int16} temp[4096]     
    \item[] \textbf{int16} input$\_$signal$\_$FFT[4096]
    \item[]
    \item[] /*********** lookup tables for computing fft of size 2048 ***********/
    \item[] \textbf{int16} temp$\_$buff[4096]
    \item[] \textbf{int8}  ScalVal[13] = {0}
    \item[] \textbf{int32} br = 1
    \item []
    \item[] /***************Copying the incoming signal (real and imaginary parts as required for FFT function) to temp for computing fft**************/
    \item[] \textbf{for i = 0 to i = 2047}
    \begin{itemize}
        \item[] temp[2*\textbf{i}]     =  incoming$\_$signal[\textbf{i}].re
        \item[] temp[2*\textbf{i} + 1] =  incoming$\_$signal[\textbf{i}].im
    \end{itemize}
    \item[] \textbf{end for}
    \item[] /************ Function for computing the FFT of input signal ************/
    \item[] \textbf{CEVA$\_$FFT$\_$LIB$\_$CX16$\_$FFT(log2$\_$FFT$\_$size, temp, input$\_$signal$\_$FFT , CEVA$\_$FFT$\_$LIB$\_$cos$\_$sin$\_$fft$\_$16 , (int16*)bitrev16bit$\_$16$\_$to$\_$2048, temp$\_$buff , ScaleVal, br)}
    \item[]
    \item[]
    \item[] \textbf{int8} SVs[32][2] = \{
        \{2, 6\},
        \{3, 7\},
        \{4, 8\},
        \{5, 9\},
        \{1, 9\},
        \{2, 10\},
        \{1, 8\},
        \{2, 9\},
        \{3, 10\},
        \{2, 3\},
        \{3, 4\},
        \{5, 6\},
        \{6, 7\},
        \{7, 8\},
        \{8, 9\},
        \{9, 10\},
        \{1, 4\},
        \{2, 5\},
        \{3, 6\},
        \{4, 7\},
        \{5, 8\}, 
        \{6, 9\},
        \{1, 3\},
        \{4, 6\},
        \{5, 7\}, 
        \{6, 8\},
        \{7, 9\},
        \{8, 10\},
        \{1, 6\},
        \{2, 7\},
        \{3, 8\},
        \{4, 9\}
    \};
     
    \item[] \textbf{int8} g1[1023]   \hspace{5mm} /*  Array for g1 LFSR */
    \item[] \textbf{int8} g2[1023]   \hspace{5mm} /* Array for g2 LFSR */
    \item[] g1 =  g1$\_$lfsr()       \hspace{5mm} /* Fucntion call */
    \item[] \textbf{int8} tap0,tap1
    \item[] \textbf{int16} gold$\_$code[2048]
    \item[] \textbf{int16} PRN$\_$code$\_$FFT[4096]
    \item[] \textbf{int16} M[4096]
    \item[] \textbf{cint16} INABS[2048]
    \item[] \textbf{uint16} OUTABS[2048]
  



    \item[] \textbf{for} \textbf{sv}=0 to \textbf{sv}=31: 
	\begin{enumerate}
    \renewcommand{\labelenumii}{\roman{enumii}}
        \item[] /******** PRN code generation ********/
        \item[] \textbf{int8} index=0    \hspace{5mm} /* index for iterating the SVs arraay */ 
        \item[] tap0 = SVs[\textbf{sv}][index]
        \item[] tap1 = SVs[\textbf{sv}][index++]
        \item[] g2 = g2$\_$lfsr(tap0,tap1)   /* Fucntion call */
        \item[] gold$\_$code = combine$\_$g1$\_$g2(g1,g2)  /* Fucntion call */
        \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 1022
        \begin{enumerate}
            \item[] if gold$\_$code[\textbf{i}] $>$  0 
            \begin{enumerate}
                \item[]  gold$\_$code[\textbf{i}] = -1
            \end{enumerate}
            \item[] else
            \begin{enumerate}
                \item[]  gold$\_$code[\textbf{i}] = 1
            \end{enumerate}
        \end{enumerate} 

    /* Upsampling the PRN code */
        \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 1022
        \begin{enumerate}
            \item[] c[\textbf{2i}] = gold$\_$code[\textbf{i}]
            \item[] c[\textbf{2i + 1}] = gold$\_$code[\textbf{i}]
        \end{enumerate}
        \item[] \textbf{end for}
        \item[] c[2046] = 0
        \item[] c[2047] = 0
    \end{enumerate}
    
    \begin{enumerate}
    \item[]
    \item[] /***************Copying the PRN code (real and imaginary parts as required for FFT function) to temp for computing FFT**************/
    \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 2047
    \begin{itemize}
        \item[] temp[2\textbf{i}]     =  c[\textbf{i}]
        \item[] temp[2\textbf{i} + 1] =  0
    \end{itemize}
    \item[] \textbf{end for}
    \item[] 
    \item[] /********* Computing the FFT for PRN code ***************/
    \item[] \textbf{CEVA$\_$FFT$\_$LIB$\_$CX16$\_$FFT(log2$\_$FFT$\_$size, temp, PRN$\_$code$\_$FFT, CEVA$\_$FFT$\_$LIB$\_$cos$\_$sin$\_$fft$\_$16 , (int16*)bitrev16bit$\_$16$\_$to$\_$2048,temp$\_$buff , ScaleVal, br)}
    \item[]
    \item[] /********** Multiplying the FFT of input signal and conjugate of FFT of PRN codes ***********/
    \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 2047
    \begin{itemize}
        \item[] M[2\textbf{i}]   = input$\_$signal$\_$FFT [2\textbf{i}] * PRN$\_$code$\_$FFT[2\textbf{i}] + input$\_$signal$\_$FFT [2\textbf{i}+1] * PRN$\_$code$\_$FFT[2\textbf{i}+1]
        \item[] M[2\textbf{i}+1] = PRN$\_$code$\_$FFT[2\textbf{i}] * input$\_$signal$\_$FFT [2\textbf{i}+1] - input$\_$signal$\_$FFT [2\textbf{i}] * PRN$\_$code$\_$FFT[2\textbf{i}+1]
    \end{itemize}
    \item[] \textbf{end for}
    \item[] 
    \item[] /******* Computing IFFT for the resultant signal **********/
    \item[] \textbf{CEVA$\_$FFT$\_$LIB$\_$CX16$\_$IFFT (log2$\_$FFT$\_$size, M, temp , CEVA$\_$FFT$\_$LIB$\_$cos$\_$sin$\_$fft$\_$16 , (int16*)bitrev16bit$\_$16$\_$to$\_$2048,temp$\_$buff , ScaleVal, br)}
    \item[] 
    \item[] /********** Copy the IFFT output to the complex array for finding power ********/
    \item[] \textbf{for i = 0 to i = 2047}
    \begin{itemize}
        \item[] INABS[\textbf{i}].re    = temp[\textbf{2i}]
        \item[] INABS[\textbf{i}].im    = temp[\textbf{2i+1}]
    \end{itemize}
    \item[] \textbf{end for}
    \item[] 
    \item[]  /******** function for computing the absolute value in array ***********/
    \item[] \textbf{CEVA$\_$DSP$\_$LIB$\_$VEC$\_$CX$\_$ABS$\_$Q15 (INABS,OUTABS,2048,1)}
    \item[] \textbf{int16} max = 0
        \item[] \textbf{for} \textbf{n}=0 to \textbf{n} = N-1
        \begin{enumerate}
            \item[] \textbf{if} OUTABS[\textbf{n}] $>$ max:
            \begin{enumerate}
                \item[] max = OUTABS[\textbf{n}]
                \item[] max$\_$index = \textbf{n}
            \end{enumerate}
           \item[] \textbf{end if}
        \end{enumerate}
        \item[] \textbf{end for} \\
      \item[] /* Update max$\_$power, visible$\_$satellites$\_$withMaxPower and codePhase arrays and the corresponding PRN codes are stored */ \\

        \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 4
        \begin{enumerate}
            \item[] \textbf{if} max $>$ max$\_$power[\textbf{i}]
            \begin{enumerate}
                \item[] \textbf{for} \textbf{j} = 4 to \textbf{j} = \textbf{i}-1
                \begin{itemize}
                    \item[] max$\_$power[\textbf{j}] = max$\_$power[\textbf{j}-1]
                    \item[] visible$\_$satellites$\_$withMaxPower[\textbf{j}] = visible$\_$satellites$\_$withMaxPower[\textbf{j}-1]
                    \item[] codePhase[\textbf{j}] = codePhase[\textbf{j}-1]
                    \item[] \textbf{j} = \textbf{j}-1
                \end{itemize} 
                \item[] \textbf{end for}
                \item[] max$\_$power[\textbf{i}] = max
                \item[] visible$\_$satellites$\_$withMaxPower[\textbf{i}] = \textbf{sv}
                \item[]  codePhase[\textbf{i}] = max$\_$index
                \item[] \textbf{for} \textbf{b} = 0 to \textbf{b} = 2048
                \begin{itemize}
                    \item[] visible$\_$PRN$\_$codes[\textbf{i}][\textbf{b}] = c[\textbf{b}]
                \end{itemize}
                \item[] \textbf{end for}
                \item[] break the loop
            \end{enumerate}
            \item[] \textbf{end if}
        \end{enumerate}
        \item[] \textbf{end for}
    \end{enumerate}
    \item[] \textbf{end for}
    \item[] 
    \item[] /* Finding the Doppler shift for 5 satellites */
    
    \item[] \textbf{int16} p$\_$inp[2048]
    \item[] \textbf{int16} cos$\_$sin$\_$out[4096]  
    \item[] \textbf{cint32} x$\_${sh}[2048]
    \item[] \textbf{cint16} code[2048]
    \item[] \textbf{cint16} *signal$\_$power
    \item[] \textbf{int16} fd[5]

    \item[]  \textbf{for} \textbf{sv} = 0  to \textbf{sv} = 4
    \begin{enumerate}
        \item[] Code phase $\hat{\tau}$ = codePhase[\textbf{sv}]
            \item[] Initialize max$\_$of$\_$max=0
            \item[] Initialize max$\_$fd    = 0

            \item[] \textbf{for} \textbf{$f_D$} = $f_{min}$ to \textbf{$f_D$} $= f_{max}$ in $f_{step}$ steps:
            \begin{enumerate}
                \item[]
                \item[]  /********* Computing the x[n].$e^{-j2 \pi F_Dt}$, for n = 0 to N-1 *********/
                \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 2047
                \begin{itemize}
                    \item[] p$\_$inp[\textbf{i}] = (2 * pi * f$\_${D} * \textbf{i} * 10430)/2048000
                \end{itemize}
                \item[] \textbf{end for}
                \item[] \textbf{CEVA$\_$DSP$\_$LIB$\_$COSSIN$\_$Q15(p$\_$inp,cos$\_$sin$\_$out,2048)}
                \item[] \textbf{for} \textbf{i} = 0 to \textbf{i} = 2047
                
                \begin{itemize}
                    \item[] x$\_$sh[\textbf{i}].re = x[\textbf{i} + $\hat{\tau}$].re * cos$\_$sin$\_$out[2i] + x[\textbf{i} + $\hat{\tau}$].im * cos$\_$sin$\_$out[2i + 1] 
                    \item[] x$\_$sh[\textbf{i}].im = x[\textbf{i} + $\hat{\tau}$].im * cos$\_$sin$\_$out[2i] - x[\textbf{i} + $\hat{\tau}$].re* cos$\_$sin$\_$out[2i+1] 
                    \item[] code[\textbf{i}].re = visible$\_$PRN$\_$codes[\textbf{sv}][\textbf{i}]
                    \item[] code[\textbf{i}].im = 0
                \end{itemize}
                \item[] \textbf{end for}
                \item[] 
                \item[] /******Multiply the PRN code with Shifted signal and Compute the power of signal *****/
                \item[] \textbf{CEVA$\_$DSP$\_$LIB$\_$MAT$\_$CX$\_$MUL$\_$Q15(x$\_$sh,code,signal$\_$power,1,2048,1)}
                \item[] z = *signal$\_$power.re
            \item[] \textbf{if}  (z $>$ max$\_$of$\_$max)
            \begin{enumerate} 
                \item[]  max$\_$of$\_$max = z
                \item[] max$\_$fd    = \textbf{$f_D$}
            \end{enumerate}
            \item[] \textbf{end if}
            
        \end{enumerate}
        \item[] \textbf{end for}
        \item[]Doppler Frequency offset fd[\textbf{sv}] = max$\_$fd
    \end{enumerate}
    $\textbf{end for}$
\end{enumerate}    

\end{document}